# Peak caling of merges
# CREO QUE A PARTIR DE AQUI VOY A HACER OTRO SCRIPT, PARA ELLO TENDRE QUE GUARDAR EL BAMFILE 
# EN ALGUN SITIO EN CONCRETO DONDE COINCIDAN LAS REPLICAS DE LA MISMA MUESTRA
# pero tambien voy a sacar los picos de las muestras por separado
# a MACS2 se le puede pasar los BAM en separado y el los junta
scriptsPath="/home/jmendietaes/programas/PhD"

module load SAMtools/1.9-foss-2018b

################################
# Merge BAM files if needed #
###############################
basePath="/home/jmendietaes/data/2021/chip/allProcessed"
bamsPath="${basePath}/bamfiles"
mergedBams="${basePath}/mergedBams"

extraFilePath="/home/jmendietaes/data/2021/chip/analysisFiles"

bed="/home/jmendietaes/data/2021/chip/analysisFiles/hg38Tables_genePos.txt"
bigwig="/home/jmendietaes/data/2021/chip/allProcessed/BigWig/valid/Mye_Brd9_140421_S31.sort.rmdup.rmblackls.rmchr.norm.bw"
bam="/home/jmendietaes/data/2021/chip/allProcessed/bamfiles/valid/Mye_Smarcb1_150521_S6.sort.rmdup.rmblackls.rmchr.bam"
name=`basename $bam | sed 's/.sort.rmdup.rmblackls.rmchr.*//g'`

controlbam="/home/jmendietaes/data/2021/chip/allProcessed/bamfiles/valid/Mye_IgG_31032021_S22.sort.rmdup.rmblackls.rmchr.bam"
outpath="/home/jmendietaes/data/2021/chip/allProcessed/furtherAnalysis"

# Number of genomic bins to use when calculating fingerprint plot (Default: 500000)
fingerprint_bins=500000

DATASETS=($(ls $bamsPath | grep "bam$" | sed -r 's/_S[0-9].*_R.*$//' | uniq))

# samtools merge ${outName} ${inName1} ${inName2}

# picard -Xmx${avail_mem}g MergeSamFiles \\
#             ${'INPUT='+bam_files.join(' INPUT=')} \\
#             OUTPUT=${name}.sorted.bam \\
#             SORT_ORDER=coordinate \\
#             VALIDATION_STRINGENCY=LENIENT \\
#             TMP_DIR=tmp
#         samtools index ${name}.sorted.bam

# de esto igual paso
SLURM_ARRAY_TASK_ID=6

computeMatrix scale-regions \
    --regionsFileName $bed \
    --scoreFileName $bigwig \
    --outFileName ${name}.computeMatrix.mat.gz \
    --outFileNameMatrix ${name}.computeMatrix.vals.mat.tab \
    --regionBodyLength 1000 \
    --beforeRegionStartLength 3000 \
    --afterRegionStartLength 3000 \
    --skipZeros \
    --smartLabels \
    --numberOfProcessors ${SLURM_ARRAY_TASK_ID}

plotProfile --matrixFile ${name}.computeMatrix.mat.gz \
    --outFileName ${name}.plotProfile.pdf \
    --outFileNameData ${name}.plotProfile.tab
plotHeatmap --matrixFile ${name}.computeMatrix.mat.gz \
    --outFileName ${name}.plotHeatmap.pdf \
    --outFileNameMatrix ${name}.plotHeatmap.mat.tab

#############################
# Phantompeakqualtools
#############################

# Phantompeakqualtools
# if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")

# BiocManager::install("Rsamtools")
# install.packages("spp", dependencies=TRUE)
#wget https://raw.githubusercontent.com/nf-core/chipseq/master/assets/multiqc/spp_rsc_header.txt
#wget https://raw.githubusercontent.com/nf-core/chipseq/master/assets/multiqc/spp_nsc_header.txt
#wget https://raw.githubusercontent.com/nf-core/chipseq/master/assets/multiqc/spp_correlation_header.txt
#wget https://raw.githubusercontent.com/crazyhottommy/phantompeakqualtools/master/run_spp.R

spp_correlation_header="${extraFilePath}/spp_correlation_header.txt"
spp_nsc_header="${extraFilePath}/spp_nsc_header.txt"
spp_rsc_header="${extraFilePath}/spp_rsc_header.txt"

# Create output dir
if [ ! -e ${outpath}/phantompeak ]; then
    mkdir -p ${outpath}/phantompeak
fi

export PATH="/home/jmendietaes/programas/miniconda3/envs/Renv/bin:$PATH"
RUN_SPP="${scriptsPath}/ChIP/cluster/02_NR_run_spp.R"
Rscript -e "library(caTools); source(\"$RUN_SPP\")" -c="${bam}" \
-savp="${outpath}/phantompeak/${name}.spp.pdf" \
-savd="${outpath}/phantompeak/${name}.spp.Rdata" \
-out="${outpath}/phantompeak/${name}.spp.out" -p=${SLURM_ARRAY_TASK_ID}

cp $spp_correlation_header ${outpath}/phantompeak/${name}_spp_correlation_mqc.tsv
# RSC values larger than 1 for all ChIP samples suggest good signal-to-noise
# Low RSC values can be due to failed or poor quality ChIP, low read 
# sequence quality and hence lots of mismappings, shallow sequencing depth 
# or a combination of these. Also, datasets with few binding sites (< 200) 
# help: https://hbctraining.github.io/Intro-to-ChIPseq/lessons/06_combine_chipQC_and_metrics.html
# The red vertical line shows the dominant peak at the true peak shift, 
# with a small bump at the blue vertical line representing the read length
# More than one red line implies weak signal
Rscript -e "load('${outpath}/phantompeak/${name}.spp.Rdata'); \
write.table(crosscorr\$cross.correlation, \
file=\"${outpath}/${name}_spp_correlation_mqc.tsv\", sep=",", \
quote=FALSE, row.names=FALSE, col.names=FALSE,append=TRUE)"
# I will merge this files after the full analysis
awk -v name=$name -v OFS='\t' '{print name, $9}' ${outpath}/phantompeak/${name}.spp.out | cat $spp_nsc_header - > ${outpath}/phantompeak/${name}_spp_nsc_mqc.tsv
awk -v name=$name -v OFS='\t' '{print name, $10}' ${outpath}/phantompeak/${name}.spp.out | cat $spp_rsc_header - > ${outpath}/phantompeak/${name}_spp_rsc_mqc.tsv

#############################
#FingerPrint
#############################
# did the antibody-treatment enrich sufficiently so that the ChIP 
# signal can be separated from the background signal?
# This tool samples indexed BAM files and plots a profile of cumulative 
# read coverages for each. All reads overlapping a window (bin) of the 
# specified length are counted; these counts are sorted and the cumulative 
# sum is finally plotted.

# get chip name
ip=$(basename $bam | cut -d'_' -f 2,3)
control=$(basename $controlbam | cut -d'_' -f 2)
# make sure that control comes from same cell as ChIP
cell1=$(basename $bam | cut -d'_' -f 1)
cell2=$(basename $controlbam | cut -d'_' -f 1)
if test "$cell1" != "$cell2"; then
    echo "ERROR"
    echo "Input and ChIP bam files come from different cells"
    echo $cell1, $cell2
    exit1
fi

# Create output dir
if [ ! -e ${outpath}/fingerPrint ]; then
    mkdir -p ${outpath}/fingerPrint
fi



plotFingerprint \
        --bamfiles ${bam} ${controlbam} \
        --plotFile ${outpath}/fingerPrint/${ip}_${fingerprint_bins}bp_plotFingerprint.pdf \
        --labels $ip $control \
        --outRawCounts ${outpath}/fingerPrint/${ip}_${fingerprint_bins}bp_plotFingerprint.raw.txt \
        --outQualityMetrics ${outpath}/fingerPrint/${ip}_${fingerprint_bins}bp_plotFingerprint.qcmetrics.txt \
        --skipZeros \
        --JSDsample ${controlbam} \
        --numberOfProcessors ${SLURM_ARRAY_TASK_ID} \
        --numberOfSamples $fingerprint_bins


## plot correlation, maybe for appart script for all at once
# generate correlation matrix
allBamFiles=`ls  ~/data/2021/chip/allProcessed/bamfiles/valid/*Smarcb1_*bam`
labels=`for i in $allBamFiles; do basename ${i} | cut -d'_' -f 1,2,3| cut -d '.' -f 1; done`

multiBamSummary bins --bamfiles ${allBamFiles} \
                -o ${outpath}/chipCorrelation/chipCorrelations.npz \
                --labels $labels --binSize 10000 \
                --numberOfProcessors ${SLURM_ARRAY_TASK_ID}

# In the future i might need to asses a code name for each plot
# if it goes in separate script will be easier
plotCorrelation --corData ${outpath}/chipCorrelation/chipCorrelations.npz \
                --corMethod spearman \
                --whatToPlot heatmap \
                --plotFile ${outpath}/chipCorrelation/chipCorrelations.pdf \
                --skipZeros \
                --plotTitle "Correlation between ChIP samples" \
                --plotFileFormat pdf \
                --outFileCorMatrix ${outpath}/chipCorrelation/chipCorrelation_matrix.tsv 

plotCorrelation --corData ${outpath}/chipCorrelation/chipCorrelations.npz \
                --corMethod spearman \
                --whatToPlot heatmap \
                --plotFile ${outpath}/chipCorrelation/scatterPlot.pdf \
                --skipZeros \
                --plotTitle "Correlation between ChIP samples" \
                --plotFileFormat pdf
                       

#############################
#PEAK CALLING
#############################
module load MACS2/2.2.7.1-foss-2018b-Python-3.6.6
module load BEDTools/2.27.1-foss-2018b

echo -e "Starting Peak calling -----------------------------------------------\n"


# Create output dir
if [ ! -e ${outpath}/MACS2 ]; then
    mkdir -p ${outpath}/MACS2
fi

if [ ! -e ${outpath}/MACS2/logs ]; then
    mkdir -p ${outpath}/MACS2/logs
fi

cd ${outpath}/MACS2
# species shortcut for MACS
species="mm"
# peaktype="narrowPeak"
#peaktype="broadPeak"
# if [ "$peaktype" == "broad" ]; then
#     peaktype2="--broad"
# else
#     peaktype2=''
# fi


total_reads=$(samtools view -c ${bam})

# narrow peaks
peaktype='narrowPeak'
macs2 callpeak \
        -t ${bam} \
        -c ${controlbam} \
        -f BAMPE \
        -g $species \
        -n $ip \
        --keep-dup all \
        --outdir ${outpath}/MACS2 2> ${outpath}/MACS2/logs/${ip}_macs2.log

mv ${outpath}/MACS2/${ip}_peaks.xls ${outpath}/MACS2/${ip}_peaks_${peaktype}.xls

npeaks=$(cat ${outpath}/MACS2/${ip}_peaks.${peaktype} | wc -l)
reads_in_peaks=$(bedtools sort -i ${outpath}/MACS2/${ip}_peaks.${peaktype} \
    | bedtools merge -i stdin | bedtools intersect -u -nonamecheck \
    -a ${bam} -b stdin -ubam | samtools view -c)
FRiP=$(awk "BEGIN {print "${reads_in_peaks}"/"${total_reads}"}")
# report
echo -e "NUMBER OF NARROW PEAKS \t ${npeaks} \n" >> ${summaryFile}
echo -e "total_reads \t reads_in_peaks \t FRIP \n" >> ${summaryFile}
echo -e "${total_reads} \t ${reads_in_peaks} \t ${FRiP}" >> ${summaryFile}

# broad peaks
peaktype="broadPeak"
macs2 callpeak \
        -t ${bam} \
        -c ${controlbam} \
        --broad \
        -f BAMPE \
        -g $species \
        -n $ip \
        --keep-dup all \
        --outdir ${outpath}/MACS2 2> ${outpath}/MACS2/logs/${ip}_macs2.log

mv ${outpath}/MACS2/${ip}_peaks.xls ${outpath}/MACS2/${ip}_peaks_${peaktype}.xls

npeaks=$(cat ${outpath}/MACS2/${ip}_peaks.${peaktype} | wc -l)
reads_in_peaks=$(bedtools sort -i ${outpath}/MACS2/${ip}_peaks.${peaktype} \
    | bedtools merge -i stdin | bedtools intersect -u -nonamecheck \
    -a ${bam} -b stdin -ubam | samtools view -c)
FRiP=$(awk "BEGIN {print "${reads_in_peaks}"/"${total_reads}"}")
# report
echo -e "NUMBER OF BROAD PEAKS \t ${npeaks} \n" >> ${summaryFile}
echo -e "total_reads \t reads_in_peaks \t FRIP \n" >> ${summaryFile}
echo -e "${total_reads} \t ${reads_in_peaks} \t ${FRiP}" >> ${summaryFile}

# wget https://raw.githubusercontent.com/nf-core/chipseq/master/assets/multiqc/peak_count_header.txt
# wget https://raw.githubusercontent.com/nf-core/chipseq/master/assets/multiqc/frip_score_header.txt
# peak_count_header="${extraFilePath}/peak_count_header.txt"
# frip_score_header="${extraFilePath}/frip_score_header.txt"

# ipflagstat=/home/jmendietaes/data/2021/chip/allProcessed/furtherAnalysis/MACS2/flagstat.txt

# echo $npeaks | awk -v ip=$ip -v OFS='\t' '{ print ip, $1 }' | cat $peak_count_header - > ${ip}_${peaktype}s.count_mqc.tsv

# Maybe im too flexible, i could add -f 0.10 or -F 0.10 to ask at least for 10% overlap
# awk -v FRiP=$FRiP -v OFS='\t' '{print ip, FRiP}' | cat $frip_score_header - > ${ip}_${peaktype}s.FRiP_mqc.tsv



if [ ! -e ${basePath}/PeakCalling ]; then
	mkdir -p ${basePath}/PeakCalling
fi

peakFile="${basePath}/PeakCalling/${filename}_peaks.narrowPeak"

# check content of twelfth line of step control file
linec=`sed "12q;d" ${stepControl}`
if [[ ${linec} != "peakCall" ]]; then 
	macs2 callpeak -t ${bamSortMarkDupBlackChr} -n ${filename} --outdir ${BaseFolder}PeakCalling/ -f BAMPE

    # QC: number of peaks
    pn=$(cat ${ip}_peaks.${peaktype} | wc -l)
    echo -e "NUMBER OF PEAKS \t ${pn} \n" >> ${summaryFile}

    # QC: FRIP (fraction of reads in peaks)
    echo -e "FRIP --------------------\n"
    echo -e "total_reads \t reads_in_peaks \t FRIP \n" >> ${summaryFile}
    total_reads=$(samtools view -c ${bam})

    # reads in peaks
    reads_in_peaks=$(bedtools sort -i ${ip}_peaks.${peaktype} \
    | bedtools merge -i stdin | bedtools intersect -u -nonamecheck \
    -a ${bam} -b stdin -ubam | samtools view -c)

    # FRiP score
    FRiP=$(awk "BEGIN {print "${reads_in_peaks}"/"${total_reads}"}")
    echo -e "${total_reads} \t ${reads_in_peaks} \t ${FRiP}" >> ${summaryFile}

    echo -e "Peak calling - done -----------------------------------------------\n"
    # store stage control info
    echo "peakCall" >> ${stepControl}
else
    echo -e "Peak calling - already done before --------------------------------\n"
fi

# anotate peaks HOMER
module load Homer/4.10-foss-2018b
# http://homer.ucsd.edu/homer/ngs/annotation.html

# Create output dir
if [ ! -e ${outpath}/HOMER ]; then
    mkdir -p ${outpath}/HOMER
fi

# narrow peaks
peaktype='narrowPeak'
annotatePeaks.pl \
        ${outpath}/MACS2/${ip}_peaks.${peaktype} \
        hg38 \
        -gid \
        -cpu ${SLURM_ARRAY_TASK_ID} \
        > ${outpath}/HOMER/${ip}_${peaktype}.annotatePeaks.txt


# MACS quality check
if [ ! -e ${outpath}/QC ]; then
    mkdir -p ${outpath}/QC
fi
# https://github.com/nf-core/chipseq
Rscript ${scriptsPath}/ChIP/cluster/02_NR_plot_macs_qc.R \
        -i ${outpath}/MACS2/${ip}_peaks.${peaktype} \
        -s ${ip} \
        -o ${outpath}/QC \
        -p macs_peak # out prefix

# Consensus peaks => R


# Remove intermediate files

# if [ -e ${BaseFolder}BAM/${filename}.sort.rmdup.rmblackls.rmchr.bam ] && [ -e ${BaseFolder}PeakCalling/${filename}_peaks.narrowPeak ] && [ -e ${BaseFolder}BigWig/${filename}.sort.rmdup.rmblackls.rmchr.norm.bw ]; then
# 	rm -rf ${BaseFolder}BAM/${filename}.sam
# 	#rm -rf ${BaseFolder}BAM/${filename}.bam
# 	#rm -rf ${BaseFolder}BAM/${filename}.sort.bam
# 	rm -rf ${BaseFolder}BAM/${filename}.sort.rmdup.bam
# 	rm -rf ${BaseFolder}BAM/${filename}.sort.rmdup.rmblackls.bam
# fi

